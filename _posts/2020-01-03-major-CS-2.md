---
layout: post
title: "컴퓨터를 전공한다는 것 2편 - 프로그래밍과 개발방법론"
description: "컴공 전공했으면 코딩은 그래도 좀 해야지.."
date: 2019-01-03
tags: [Computer science, Computer Engineering, University, 프로그래밍, 소프트웨어, 컴퓨터, 컴퓨터과학, 컴퓨터공학, 대학, 전공]
category: "Why computer?"
img: wama.jpg
comments: true
share: true
---

[지난 포스팅](https://jeonhyun97.github.io/major-CS-1/)에서 우리는 컴퓨터공학과에서 배우는 과목들에 대해 알아보고:

1. **컴퓨터 시스템 :** 디지털시스템설계, 컴퓨터 SW시스템 개론, 컴퓨터 네트워크, 컴퓨터구조, 운영체제
2. **프로그래밍, 개발방법론 :** 프로그래밍과 문제해결, 객체지향프로그래밍, 소프트웨어설계방법
3. **수학 :** 미적분학, 선형대수학, 이산수학, 확률과 통계
4. **계산이론 :** 데이터구조, 알고리즘, 프로그래밍언어론, 오토마타 & 형식언어

또 그 중에서 컴퓨터 시스템이 무엇인지에 대해 중점적으로 살펴보았다. 요약하자면, 결국 컴퓨터 시스템은 사용자가 원하는 소프트웨어를 쉽게 사용할 수 있는 환경을 만들어 놓은 것이다. 그렇다면, **소프트웨어**는 어떻게 디자인되고, 또 개발되어야 할까? 그리고 어떻게 해야 소프트웨어를 **개발**하는 과정인 **프로그래밍**을 잘 할 수 있을까? 컴퓨터를 전공했다면 당연히 이러한 질문에 답할 준비가 되어 있어야 할 것이다. 1편에서 그랬듯이, 이번에도 포항공대 컴퓨터공학과가 제공하는 커리큘럼을 따라 **소프트웨어**, **프로그래밍**, 그리고 **개발방법론**에 대해 이해해 보자. 


### 컴퓨팅 사고력과 프로그래밍 - "프로그래밍과 문제해결"

#### Computational Thinking
어느 순간부터 "컴퓨팅 사고력 (Computational Thinking) 이라는 말이 주목받기 시작한 것 같다. 여기저기서 컴퓨터 사고력을 기르느니 마느니 하고 있고, 이 떄문인지 코딩교육이 정규 교육과정으로 들어가기도 했다. 그럼 컴퓨팅 사고력이 대체 무엇일까? 위키피디아에서는 다음과 같이 적어놓았다. 

---
In education, computational thinking (CT) is a set of problem-solving methods that involve expressing problems and their solutions in ways that a computer could execute. It involves the mental skills and practices for 
1. Designing computations that get computers to do jobs for us, and 
2. Explaining and interpreting the world as a complex of information processes. 

Those ideas range from basic CT for beginners to advanced CT for experts. 

Reference: [ Wikipedia, Compuatational Thinking](https://en.wikipedia.org/wiki/Computational_thinking) 

---
이를 ~~대충~~ ~~의역을 섞어~~ 번역하면 이렇다. 

---
교육 분야에서, 컴퓨팅 사고력(CT)이란 어떠한 문제와 그 해답을 컴퓨터가 실행할 수 있는 방향으로 이해하고 표현하는 과정을 포함한 문제해결 방법론을 뜻한다. CT에는 
1. 컴퓨터가 우리를 위해 해야 할 일들과 계산을 디자인하고,
2. 실제 세상을 정보화된 요소와 프로세스들의 조합으로 설명하고 해석하는

능력과 이를 위한 연습이 포함된다. 
이런 중요한 아이디어들은 초보자를 위한 기본적인 CT부터 전문가를 위한 고급 CT에까지 두루 통용된다.

---



잠시 여담을 덧붙이자면, 개인적으로 이 "컴퓨팅 사고력"이라는 말을 그렇게 좋아하지는 않는다. 이 용어가 요즘 약간 만병통치약처럼 쓰인다는 느낌이 들기 때문이다. 높으신 분들은 때로 "인공지능" 이나 "블록체인"을 뭐든 할 수 있는 무인단물로 생각하시는데, 언젠가부터 "컴퓨팅 사고력"이라는 용어에도 너무 집착하시는 것 같다. 모두가 "현대인의 필수 소양이라고 여겨지는" 컴퓨팅 사고력을 길러야 할 필요는 없는데, 굳이 이거를 교육에 어거지로 집어넣는다는 느낌이 든다. 

내가 이렇게 스스로의 ~~추악하고 더러운~~ 의견을 피력하는 까닭은, 세상 모든 일에 컴퓨팅 사고력이 필수적이지는 않고, 오히려 도움이 되지 않는 경우도 많다고 생각하기 때문이다. 아직까지 많은 분야가 컴퓨터가 흉내낼 수 없는 인간의 통찰력에 의존한다. 예술 쪽이 특히 그렇다. 물론 인공지능의 급격한 발달로 컴퓨터는 인간의 통찰력을 상당히 높은 수준으로 흉내내고 있지만, 미래에도 여전히 사람이 그린 그림, 사람이 만든 음악에 대한 수요는 존재할 것이다. 또한 곧 많은 일들이 소수의 전문가들에 의해 개발된 AI에 의해 대체되고, 사람들은 좀 더 여가에 집중할 수 있는 환경이 조성될 것이다. 이런 상황에서, 소프트웨어 교육뿐만 아니라 학생들의 감성과 개성을 길러줄 수 있는 음악, 미술, 문학 등 예술 관련 교육에도 투자하는 것이 옳지 않을까?


뭐, 그렇다고 해서 "컴퓨터 사고력은 필요없고, 교육할 필요도 없다!!" 라고 이야기하는 것이 아니다. 컴퓨터를 사용하지 않더라도, CT는 많은 상황에서 도움이 된다. 다음과 같은 문제 상황을 생각해 보자.

> #### 오늘 해야 할 일!!
>> 당신은 엄청난 집중력의 소유자이기에 한 가지 일을 시작하면 멈출 수 없다. 그렇다면 어떤 순서로 일을 해야 가장 빨리 끝낼 수 있을까?
> - 빨래하기
>   - 빨랫감을 세탁기에 넣는 데 10분 소요 예정 
>   - 세탁기는 50분 동안 돌아감 
>   - 빨랫감을 빼서 정리하는 데 10분 소요 예정
>   - 세탁이 끝나자마자 빼야 빨랫감이 썩지 않음.
> - 청소하기
>   - 50분 소요 예정
> - 블로그에 포스팅하기
>   - 40분 소요 예정

<center><img src="https://jeonhyun97.github.io/images/wama.jpg" width="450" ></center>

*<center>세탁기에서 빨리 안빼면 냄새남 ㅇㅇ</center>*

만일 청소와 블로그 포스팅을 빨래보다 앞서 한다면 세탁기가 돌아가는 50분이 붕 떠 버리기에, 세탁기가 돌아가는 동안 뭔가 다른 일을 하는 것이 합리적이다. 그렇다면 그 시간 동안 청소를 해야 할까, 블로그에 포스팅을 올려야 할까? 만일 블로그 포스팅을 선택한다면, 블로그 포스팅을 끝마치고도 세탁기가 10분 더 돌아가야 하기 때문에 이 시간이 낭비된다. "빨래하기"의 4번째 조건 (세탁이 끝나자마자 빨랫감을 빼야 함)이 없다면 그냥 청소를 이어서 한 후 빨랫감을 빼면 되겠지만, 문제 상황은 그렇지 않고, 시간 낭비를 최소화하기 위해서는 세탁기가 돌아가는 동안 청소를 해야 한다. 그러므로 

- **빨랫감 넣기 -> 청소하기 -> 빨랫감 빼기 -> 블로그에 포스팅하기** 혹은  
- **블로그에 포스팅하기 -> 빨랫감 넣기 -> 청소하기 -> 빨랫감 빼기**
  
의 순서로 일을 처리하는 것이 가장 효율적이다. 

방금 문제를 해결한 방식이 바로 컴퓨팅 사고력을 적용한 것이다. 이처럼, 컴퓨팅 사고력은 컴퓨터, 혹은 프로그래밍과 결부된 개념이 아니다. 애초에 이름부터가 "Computer Thinking"이 아니라 "Computational Thinking"이 아닌가. 사람도 Computation (계산) 할 수 있는 능력을 갖추고 있고, 컴퓨팅 사고력은 사람이 이 계산 능력을 어떻게 효율적으로 사용할지에 대한 개념이기도 하다. 


아무튼, 과학 또는 공학을 공부하는 학생에게 *컴퓨팅 사고력*이 필수 소양임은 자명하다. 이미 대부분의 과학 분야가 전산화되었고, 연구자에게 컴퓨터를 효과적으로 사용하는 능력은 굉장히 중요하다. 그렇기에 대부분의 공과대학에서 기초 프로그래밍을 1학년 필수 과목으로 수강하게 하고, 우리 학교에서도 이를 "프로그래밍과 문제해결"이라는 이름으로 매 학기 열고 있다. 이 과목을 수강하면서 학생들은 문제 상황을 어떻게 해석하고, 이를 컴퓨터를 활용해 어떻게 해결해야하는지를 실습하며 컴퓨팅 사고력을 기르게 된다. 컴퓨터를 전공하고자 하는 학생들 역시 이 과목을 통해 이후 배워야 할 전공 지식들을 습득하고 프로젝트를 수행할 수 있는 기본 능력을 갖추게 된다. 

#### Hello, World!!

물론 이 과목에서 가르치고자 하는 것이 컴퓨팅 사고력만은 아니고, 기초적인 프로그래밍 능력을 키우게 하려는 목적도 있다. 컴퓨터를 전공하는 학생에게 다양한 프로그래밍 언어를 이해하고 다룰 수 있는 능력은 필수적인데, 사실 한 가지 언어만 제대로 배워 놓으면 다른 언어를 배우기 그리 어렵지 않다. 대부분의 언어가 `for`, `while`, `do while` 꼴의 반복문과 `if` `else` 등으로 구성된 조건문을 기반으로 만들어진 비슷한 문법을 가졌기 때문이다. 물론 프로그래밍 언어의 핵심과 최신 기능 파악하려면 많은 노력이 필요하겠지만, 한 가지 언어만 일정 수준으로 익혀 놓는다면 다른 언어에서도 빠른 속도로 문법을 익히고 코드를 읽고 쓸 수 있다. "프로그래밍과 문제해결"에서는 학생들이 이런 능력을 갖도록 도와준다. 포항공대의 경우 `Hello, World!!`를 터미널에 찍어보는 것부터 시작해 조건문, 반복문, 포인터, 배열, 함수, 간단한 자료구조와 알고리즘에 이르기까지 다양한 프로그래밍 기본 지식을 C언어로 가르치고 구현해보게 한다. 이를 통해 학생들은 기본적인 프로그래밍 능력을 습득하고, 또한 Visual Studio나 linux, Vim editor와 같은 다양한 개발환경을 접해보는 경험도 하게 된다. 

사담으로, 사실 나는 이 기초 프로그래밍 과목을 C로 가르치는 것이 그다지 효율적이지는 않다고 생각한다. 이는 C가 프로그래머에게 상당한 자율성과 컴퓨터 시스템에 접근할 권한을 주는 대신, 그만큼 복잡하고 어려운 문법을 가지고 있기 때문이다. 코드를 디버깅하고 실행하는 과정 역시 너무 복잡하다. 이 때문에 C는 대부분 극한의 최적화가 필요한 운영체제나 임베디드시스템 프로그램을 구현할 때 많이 사용한다. 프로그래밍을 처음 접하는 학생들에게 이런 어려운 언어를 가르치는 것은 비효율적이다. 또한 통계, 물리, 전자 등 다양한 분야에서 사용할 수 있는 라이브러리와 도구들을 사용할 수 있는 최신 언어들과 달리, C는 다른 분야에서 사용하기 힘들다. 이와 같은 이유로 카이스트를 포함한 많은 대학에서 기초 프로그래밍 과목에서 가르치는 언어를 쉽게 사용할 수 있는 python이나 java로 변경하는 추세다. 물론 C를 가르침으로서 얻는 장점도 있다. 언어 자체에서 컴퓨터 시스템에 접근할 수 있는 상당한 권한을 주는 만큼, C를 사용하는 것만으로도 기본적인 컴퓨터 시스템에 대해 배울 수 있다. 사실 컴퓨터를 전공하고자 하는 학생들만 있다면 C를 사용하는 것이 훨씬 더 나은 교육과정이겠지만, 다양한 학과의 학생들이 수강하는 만큼 좀 더 쉽고 실용적인 언어로 교육과정을 개편하는 것이 낫지 않을까?


### 세상을 프로그래밍하다 - 객체지향프로그래밍

초기 프로그래밍은 어떠한 *계산*을 컴퓨터에게 시키는 데 초점을 맞췄다. 암호를 풀거나 우주선의 궤적을 계산하는 것과 같은 사람이 하기 어려운 계산들을 컴퓨터가 대신하도록 했던 것이다. 그렇다면, 어떻게 복잡한 계산을 프로그래밍할 수 있을까? 답은 간단하다. 전체 과정을 간단한 여러 단계로 나누어, 각 단계를 수행하는 모듈을 구현하고, 만든 모듈들을 순차적으로 호출하면 된다. 

이러한 방식을 **절차적 프로그래밍 (Procedural Programming)** 이라 부른다. 연속적인 프로시저 호출을 바탕으로 원하는 연산을 수행하는 절차적 프로그래밍은 꽤 오랜 세월 동안 지배적인 프로그래밍 패러다임이었다. 하지만 컴퓨터 프로그램이 점차 복잡해지고 커지면서 이 패러다임만으로는 소프트웨어를 설계하고 구현하기 어려운 경우가 점점 많아졌다. 예를 들어 당신이 지금 살고 있는 집에서 일어나는 모든 상호작용을 시뮬레이팅하는 프로그램을 만들거나, 다양한 유닛들이 실시간으로 상호작용하는 게임을 개발한다고 생각해 보자. 연속적인 명령어를 호출하는 것만으로는 이를 구현하기 쉽지 않을 것이다. 이러한 문제를 해결하기 위해 등장한 패러다임이 바로 **객체지향 프로그래밍(Object-Oriented Programming)** 이다. 

객체지향 프로그래밍이란 서로 독립된 **객체**의 집합과 상호작용을 기반으로 프로그램을 설계하는 것이다. 객체라는 개념이 처음 소개된 것은 1962년 개발된 [Simula](http://www.simula67.info/)라는 프로그래밍 언어에서였지만, 이후 한동안 주목받지 못했다. 그러나 1980~1990년대 프로그래밍 언어의 급격한 발전과 함께 객체지향 프로그래밍은 많은 발전을 이루었고, 현재 상당수의 주류 프로그래밍 언어에서는 이 개념을 지원한다. 

그렇다면 객체지향 프로그래밍은 절차적 프로그래밍과 비교해 어떤 점이 우위에 있는 걸까? 위에서 잠시 언급했던 "당신의 집을 시뮬레이팅하는 프로그램"에 대해 생각해 보자. 객체지향 개념을 적용한다면 당신의 집에서 일어나는 수많은 일들을 서로 다른 객체의 상호작용으로 쉽게 표현할 수 있을 것이다. 예를 들어 당신이 냉장고에서 어제 먹다 남긴 치킨을 꺼내는 상황을 다음과 같이 프로그래밍할 수 있을 것이다 :

1. **사람**이라는 객체, **냉장고**라는 객체, **치킨**이라는 객체를 만든다.
2. **사람**이 **냉장고**에서 **무언가**를 꺼내는 프로시저를 구현한다. 
3. **무언가**의 위치에 **치킨**을 넣어 구현한 프로시저를 호출한다. 

이와 같이 객체지향 프로그래밍 패러다임을 사용하면 실제 세상에서 일어나는 일들을 매우 간단하게 프로그램으로 옮길 수 있다. 이뿐만이 아니다. 객체지향 프로그래밍은 개발 과정 자체를 효율적으로 만든다. 만일 위의 예시에서 사람이 치킨이 아닌 과메기를 꺼내는 경우가 새로 생긴다면, **과메기**라는 객체를 만든 후 치킨을 과메기로 치환하면 된다. 또한, 과메기와 치킨이 둘 다 음식이라는 공통점을 가지고 있음에 착안해 **음식**이라는 공통 객체를 설계한 후, 과메기와 치킨에 대한 설계는 **음식** 객체를 기반으로 한다면 훨씬 효율적으로 각 객체를 설계할 수 있다. 이 경우 **음식** 객체를 후에 이 설계를 재사용해 피자, 짜장면, 초밥 객체 역시 쉽게 디자인할 수 있을 것이다.

이처럼, 객체지향 프로그래밍 패러다임을 통해 프로그래머는 훨씬 직관적, 효율적으로 프로그램을 설계할 수 있다. 이 때문에 컴퓨터를 전공한다면 대부분의 경우 첫 전공 과목으로 객체지향프로그래밍을 수강하게 된다. 물론 이를 배우는 과정에서 새로운 객체지향 패러다임 언어를 배우는 것은 덤이다. 나는 당시 C++을 처음 접했었는데, 다양한 실습과 과제, 프로젝트를 수행하며 C++과 객체지향 개념에 익숙해진 경험은 이후 다양한 프로그래밍 언어를 빠르게 익히는 데 많은 도움이 되었다. 

### 소프트웨어 개발방법론 - 소프트웨어설계방법

이 섹션에서 소개하고자 하는 **소프트웨어설계방법**은 사실 나에게 있어 굉장히 의미있는 수업이다. 이 수업을 바로 지난학기 (2019년 가을) 에 수강했는데, 사실 그 직전 여름방학까지만 해도 나는 프로그래머보다는 전산학을 연구하는 컴퓨터과학자가 되고 싶었다. 정확히 말하자면, 개발이 너무 비효율적인 과정이라고 느껴졌다. 그 전에도 다양한 프로젝트와 조별과제를 해봤지만, 재미와 실력 향상을 통해 얻는  이득보다 온갖 삽질과 프리라이더들이 선사하던 스트레스로 인한 손해가 더 큰 것 같았다. 또 이렇게 코딩하고 디버깅하고 무임승차자들이랑 싸울 시간에 수학 문제 한 문제 더 푸는 것이 더 이득이라고 생각했다.

그래서 교수님께서 선사하신다는 8인 조별과제를 어떻게 스트레스받지 않고 대충 끝낼 수 있을까 개강 전부터 엄청 고민했는데, 이 걱정이 기우임이 밝혀지기까지는 얼마 걸리지 않았다. 어떻게 내 걱정이 해소되었고, 내가 개발자의 길을 걸어도 괜찮을 것 같다는 생각을 하게 되었는지 알기 위해, 이 과목에서 도대체 무엇을 가르치는지 알아보자. 

#### 효율적인 소프트웨어 개발이란?

컴퓨터공학을 전공하는 학생은 누구나 기초 프로그래밍과 객체지향에 대해 배우고, 이것저것 프로젝트도 진행해보면서 만들고 싶은 소프트웨어를 개발할 수 있는 능력을 가지게 된다. 그러나 소프트웨어 개발을 혼자 하는 경우는 거의 없고, 대부분의 경우 다른 사람들과 협업하게 된다. 내가 작성한 코드를 다른 사람이 보고 수정하거나, 그 반대의 상황이 발생하는 경우도 많다. 다른 사람이 만든 기능과 내가 만든 기능을 통합해야 하는 경우도 생긴다. 이렇듯, 소프트웨어를 개발하는 과정은 굉장히 복잡하고 예기치 못한 일 역시 자주 발생한다. 이런 상황에서 어떻게 해야 프로세스의 복잡도를 조금이라도 줄이고 효율적으로 개발을 진행할 수 있을까?

##### 코드를 "잘" 작성하는 방법

일단 기본적으로 코드를 **잘** 작성하는 것이 중요하다. 내가 만일 코드를 개판으로 짜놓는다면, 협업자가 코드를 읽고 이해하는 데 오랜 시간이 걸리며 이를 고치기도 쉽지 않을 것이다. 그럼 대체 어떤 코드가 잘 작성된 코드일까? 다음 예시를 통해 알아보자. 


```c
int main() {
    ...
    if (a >= 0)
        result = result + a;
    else        
        result = result - a;
    if (b >= 0)
        result = result + b;
    else        
        result = result - b;
    if (c >= 0)
        result = result + c;
    else        
        result = result - c;

    print(result);
}
```

위 코드는 `result`에 `a`의 절댓값, `b`의 절댓값, `c`의 절댓값을 더해 이 값을 출력하는 함수다. 코드를 들여다보면 `a`, `b`, `c`가 0 이상일 경우 `result`에 그대로 더해주고, 0보다 작으면 부호를 바꿔 더해주는 것을 알 수 있다. 그런데 뭔가 코드가 좀 알아보기 힘들고, 괜히 반복된 부분이 많은 것 같다는 느낌이 들지 않는가? 아래 코드를 한번 살펴보자.
```c
// 인자로 받은 정수의 절댓값을 반환한다.
int abs(int value) {
    if (value >= 0) return value;
    else            return -value;
}

int main() {
    ...
    result = result + abs(a) + abs(b) + abs(c);
    print(result);
}

```

이 코드에서는 절댓값을 구하는 과정을 따로 분리해 `abs`라는 새로운 **함수**로 만들었다. 이 함수는 `value`를 인자로 받아 그 값의 절댓값을 반환한다. 이 함수를 이용할 경우 메인(`main`) 프로시저가 훨씬 더 간단해짐은 물론, *`result`에 `a`의 절댓값, `b`의 절댓값, `c`의 절댓값을 더한다*라는 중요 기능이 잘 드러난다. 적절한 함수 이름과 주석 역시 코드의 이해를 도와주고 있다. 위 코드에서는 영어로 절댓값을 의미하는 absolute value의 축약어 `abs`를 함수 이름으로 사용했고, 함수의 설명 - 인자로 받은 정수의 절댓값을 반환한다 - 을 주석으로 적어놓았다. 이를 통해 굳이 `abs` 내의 세부적인 코드를 읽지 않아도 이 함수가 절댓값 함수임을 쉽게 알 수 있게 된다. 게다가 나중에 절댓값이 필요한 경우가 있으면 그냥 `abs`를 불러오는 방식으로 쉽게 기능을 구현 가능하다. 

누가 봐도 첫번째 코드보다 두번째 코드가 더 **잘** 작성한 코드일 것이다. 이 과목에서는 이와 같이 코드를 **잘** 작성하는 방법들을 가르쳐준다. 여기에는 코드의 설계와 구현에서부터 시작해 효과적으로 테스트하는 방법, 소프트웨어를 설명하는 문서를 작성하는 방법 등 다양한 방법론이 포함된다. 이러한 전략들을 도입함으로써 프로그래머들은 버그를 줄이고 효율적으로 서로의 코드를 이해, 수정할 수 있게 된다.

##### 커뮤니케이션을 "잘" 하는 방법

아무리 코드를 **잘** 작성한다 하더라도, 개발자들 간 커뮤니케이션이 제대로 이뤄지지 않는다면 프로젝트는 산으로 가게 된다. 사실 몇십년 전만 해도 괜찮았다. 초기 소프트웨어는 국가에 의해 군사용으로 개발된 경우가 많은데, 이 때문에 계획을 딱 세우고 그 계획대로 정확히 개발하는 것이 효율적이었다. 각 개발자는 자기가 맡은 부분만 요구사항을 제대로 만족하도록 개발하면 되기에 커뮤니케이션이 그리 중요하지 않았다. 그러나 시간이 지나고 소프트웨어의 타겟이 일반 대중으로 바뀌고, 소프트웨어의 수명과 업데이트 주기가 짧아지면서 이와 같은 계획 중심 개발 프로세스는 굉장히 비효율적으로 변했다. 계속해서 주위 환경과 요구사항이 바뀌는 현대 소프트웨어 개발 산업에서 개발자들 간 서로 정보를 주고받고 변화를 반영하는 커뮤니케이션의 중요성은 상당히 높아졌다. 

비단 개발자뿐만이 아니다. 어떠한 소프트웨어를 개발하는 데는 그 소프트웨어를 사용할 유저와의 대화도 필수적이다. 유저가 계속해서 소프트웨어를 점검하고 피드백을 주지 않으면 최종 결과물이 유저의 기대와 판이하게 달라 처음부터 다시 개발해야 하는 일이 생길 수도 있다. 

그래서 개발자들은 커뮤니케이션을 효과적으로 할 수 있는 방법을 연구했고, 그 결과로 탄생한 것이 바로 **에자일(Agile) 방법론**이다. 위키피디아에 따르면, 에자일 방법론이란 소프트웨어 개발 기간을 짧은 단위로 나누고, 각 단위마다 끊임없이 프로토타입을 만들어내며 그때 그때 필요한 요구를 더하고 수정하여 하나의 커다란 소프트웨어를 개발해나가는 것을 뜻한다 ([출처](https://ko.wikipedia.org/wiki/%EC%95%A0%EC%9E%90%EC%9D%BC_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C)). 각 주기마다 개발자들은 서로의 작업을 점검하고, 새로운 변화 (개발환경 변화, 발견된 버그, 요구사항의 변화 등) 를 반영해 무엇을 개발할지 정한다. 이를 통해 팀은 주위 환경의 변화에 기민하게 대응할 수 있고, 현재 개발 프로세스에 집중하며 소프트웨어를 효율적으로 개발할 수 있게 된다. 사실 이 설명은 굉장히 축약화된 것인데, 자세한 정보가 궁금하다면 [영문 위키피디아](https://en.wikipedia.org/wiki/Agile_software_development)를 참고하자.

#### 그래서...

지금까지 이 과목에서 배울 수 있었던 "코드를 **잘** 작성하는 방법"과 "커뮤니케이션을 **잘** 하는 방법"에 대해 살펴보았다. 다시 조별과제 얘기로 돌아가자면, 여기서 배운 방법론을 효과적으로 적용한 결과 굉장히 복잡하고 규모도 큰 프로젝트였음에도 성공적으로 끝마칠 수 있었다. 커뮤니케이션을 다소 강제(?)하는 에자일 방법론 덕에 외국인 유학생들의 프리라이딩 역시 억제할 수 있었다. 그리고 무엇보다 이 효율적인 과정을 체험하면서 개발이 정말 재밌는 것이라는 느낌을 받았다. 그래서 이후 개인 프로젝트도 이것저것 하고 있고, 대학원에서 전공하려는 분야도 좀 더 실용적인 쪽으로 바꾸었다. 

포항공대 컴퓨터공학과에서는 18학번부터 이 과목을 필수로 듣지 않아도 되는 선택과목으로 전환했다. 뭐, 이런 내용은 사실 인턴을 통해서도 체험할 수 있고, 하여튼 배울 수 있는 창구는 많다. 그럼에도 뭔가 아쉽다. 개발을 재미없어했지만 이 과목을 통해 개발하는 과정의 참맛을 느끼게 될 학생이 나 이후에 없진 않을 것이니...

----------------

이번 포스팅에서는 기본적인 프로그래밍 관련 지식부터 시작해 어떻게 소프트웨어를 효과적으로 설계하고, 또 어떻게 효율적으로 개발을 진행할 수 있을지까지 살펴보았다. 지난 포스팅에서 하드웨어와 컴퓨터 시스템에 대해 알아보았고, 이번에 소프트웨어에 대해 알아보았으니 사실 "컴퓨터" 자체에 대해서는 대충 다 알아본 셈이 된다. 그렇다면, 이 모든 것을 뒷받침하고 있는 이론적 배경이 궁금하지 않은가? 다음 포스팅 - 수학과 계산이론 - 을 참조하자.







#### 관련 포스팅


[컴퓨터를 전공한다는 것 1편 - 컴퓨터 시스템](https://jeonhyun97.github.io/major-CS-1/)

[컴퓨터를 전공한다는 것 3편 - 계산이론](https://jeonhyun97.github.io/major-CS-3/)


